# Analysis: Why Integration Tests Use Both Legacy Jaeger SDK and Zipkin

## Executive Summary

The integration tests in this repository use **both** the legacy Jaeger SDK (via `jaeger-client` v0.34.3) and Zipkin Brave SDK (v4.19.3) to test the Spark dependency job's ability to correctly calculate service dependency links from traces generated by different tracing systems. This is intentional and necessary because Jaeger and Zipkin use fundamentally different span models, which the dependency calculation logic must handle correctly.

## Key Finding: Different Span Models

### Jaeger Span Model (Individual Spans)
- **One span per operation**: Each service creates its own span for an operation
- **Parent-child relationships**: Uses explicit span references (CHILD_OF, FOLLOWS_FROM)
- **No span sharing**: Client and server sides each create separate spans
- **Example**: Service A calls Service B:
  - Service A creates Span 1 (client span)
  - Service B creates Span 2 (server span) with reference to Span 1

### Zipkin Span Model (Shared Spans)
- **Shared span ID**: Client and server can share the same span ID
- **Span annotations**: Uses cs (client send), sr (server receive), ss (server send), cr (client receive) annotations
- **Span joining**: A single span ID can have multiple "sub-spans" (client-side and server-side views)
- **Example**: Service A calls Service B:
  - Client side creates Span 1 with cs/cr annotations (client span)
  - Server side joins Span 1 with sr/ss annotations (server span)
  - Both reported with the same span ID but different span.kind tags

## Impact on Dependency Link Calculation

The `SpansToDependencyLinks.java` class contains special logic to handle both models:

### 1. Shared Span Detection (Lines 70-76, 140-167)
```java
// Map of parents - detects shared spans (same span ID)
Set<Span> sharedSpans = spanMap.get(span.getSpanId());
```
The code builds a map where multiple spans can share the same span ID, which is characteristic of the Zipkin model.

### 2. Zipkin Shared Span Dependencies (Lines 78-79)
```java
// Let's start with zipkin shared spans
List<Dependency> result = sharedSpanDependencies(spanMap);
```
First, it extracts dependencies from shared spans by looking for CLIENT/PRODUCER and SERVER/CONSUMER tags within the same span ID.

### 3. Jaeger Individual Span Dependencies (Lines 81-109)
For non-shared spans or single spans per ID, it uses parent-child references to derive dependencies:
```java
// this is jaeger span or zipkin native (not shared!)
Span parent = parents.iterator().next();
result.add(new Dependency(parent.getProcess().getServiceName(), span.getProcess().getServiceName()));
```

### 4. Client Span Preference for Shared Spans (Lines 87-91)
```java
// if the current span is shared and not a client span we skip it
// because the link from this span to parent should be from client span
if (spanMap.get(span.getSpanId()).size() > 1 && !isClientSpan(span)) {
    continue;
}
```
To avoid double-counting, when processing shared spans, only the client-side span creates the dependency link.

## Does It Make a Difference?

**No, the calculated dependency links should be identical** when the test infrastructure is set up correctly. Here's why:

### Expected Behavior
Both approaches should produce the same dependency graph:
- **Service A â†’ Service B** produces one dependency link with count=1
- The difference is only in HOW the spans are structured, not WHAT dependencies exist

### Test Infrastructure Compensates for Differences

#### In `DependencyLinkDerivator.java` (Lines 36-52)
The test expectation calculator includes special handling for Zipkin:
```java
// zipkin spans - there is a span representing an internal link in service
// e.g. for each descendant there is a separate client span (we follow zipkin semantics)
if (child.getTracingWrapper().get() instanceof TracingWrapper.ZipkinWrapper) {
    if (!child.getDescendants().isEmpty()) {
        // Adds internal service calls to expected dependencies
        stringLongMap.put(child.getServiceName(), internalCallCount + child.getDescendants().size());
    }
}
```

This accounts for Zipkin creating additional client spans for internal calls within the same service.

#### In `TracingWrapper.ZipkinWrapper` (Lines 107-123)
The test code explicitly creates both client and server spans to match Zipkin's shared span model:
```java
brave.Span parentClient = parent.get().tracing.tracer().newChild(parent.get().span.context())
    .kind(Kind.CLIENT)
    .name(operationName + "-client")
    .start();
parentClient.finish();
span = tracing.tracer().joinSpan(parentClient.context())
    .name(operationName + "-server")
    .kind(Kind.SERVER)
    .start();
```

## Why Both SDKs Are Necessary

1. **Real-world compatibility**: Jaeger backend accepts traces from both Jaeger clients and Zipkin clients (via Zipkin-compatible API on port 9411)

2. **Comprehensive testing**: The Spark dependency job must correctly process traces regardless of which tracing SDK generated them

3. **Edge case coverage**: Shared spans are a complex edge case that requires special handling in the dependency calculation logic

4. **Historical context**: Reference to [Jaeger Issue #451](https://github.com/jaegertracing/jaeger/issues/451) in the code indicates this was a known challenge in handling Zipkin's span model

## Evidence from Code

### Dependencies in `pom.xml` (Lines 41-68 of test module)
- `io.jaegertracing:jaeger-client:0.34.3` - Legacy Jaeger SDK
- `io.zipkin.brave:brave:4.19.3` - Zipkin Brave SDK
- `io.zipkin.reporter:zipkin-sender-okhttp3:1.0.2` - Zipkin reporter

### Test Methods in `DependenciesTest.java`
- `testJaegerOneTrace()` - Tests with Jaeger SDK
- `testJaegerMultipleTraces()` - Tests with Jaeger SDK
- `testZipkinOneTrace()` - Tests with Zipkin SDK
- `testZipkinMultipleTraces()` - Tests with Zipkin SDK
- `testMultipleReferences()` - Tests complex reference types (CHILD_OF, FOLLOWS_FROM)

### Collector Configuration
Both collectors are exposed in tests (e.g., `CassandraDependenciesJobTest.java`):
```java
collectorUrl = String.format("http://localhost:%d", jaegerCollector.getMappedPort(14268));
zipkinCollectorUrl = String.format("http://localhost:%d", jaegerCollector.getMappedPort(9411));
```
- Port 14268: Jaeger native collector endpoint
- Port 9411: Zipkin-compatible collector endpoint

## Conclusion

The use of both legacy Jaeger SDK and Zipkin in integration tests is:

1. **Intentional**: Tests both span models supported by Jaeger
2. **Necessary**: Ensures the dependency calculation logic handles both models correctly
3. **Does not affect results**: The final dependency links should be identical, as both the calculation logic and test expectations are designed to normalize the differences
4. **Best practice**: Validates real-world scenarios where Jaeger backend receives traces from heterogeneous clients

The dependency calculation logic in `SpansToDependencyLinks.java` is sophisticated enough to handle both models and produce consistent results, which is verified by the comprehensive test suite using both SDKs.
